[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "importlib.metadata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "pythoncom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pythoncom",
        "description": "pythoncom",
        "detail": "pythoncom",
        "documentation": {}
    },
    {
        "label": "win32api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32api",
        "description": "win32api",
        "detail": "win32api",
        "documentation": {}
    },
    {
        "label": "win32con",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32con",
        "description": "win32con",
        "detail": "win32con",
        "documentation": {}
    },
    {
        "label": "win32file",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32file",
        "description": "win32file",
        "detail": "win32file",
        "documentation": {}
    },
    {
        "label": "wmi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wmi",
        "description": "wmi",
        "detail": "wmi",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "cgi",
        "description": "cgi",
        "isExtraImport": true,
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "make_server",
        "importPath": "wsgiref.simple_server",
        "description": "wsgiref.simple_server",
        "isExtraImport": true,
        "detail": "wsgiref.simple_server",
        "documentation": {}
    },
    {
        "label": "request_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "application_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "shift_path_info",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "browser_cookie3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "browser_cookie3",
        "description": "browser_cookie3",
        "detail": "browser_cookie3",
        "documentation": {}
    },
    {
        "label": "http.cookiejar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "http.cookiejar",
        "description": "http.cookiejar",
        "detail": "http.cookiejar",
        "documentation": {}
    },
    {
        "label": "read_requirements",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def read_requirements(file_path):\n    \"\"\"Lire les packages requis dans le fichier de requirements\"\"\"\n    required_packages = set()\n    with open(file_path, 'r') as file:\n        for line in file:\n            line = line.strip()\n            if line and not line.startswith('#'):\n                package_name = line.split('==')[0].split('<')[0].split('>')[0].strip()\n                required_packages.add(package_name.lower())\n    return required_packages",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "install_modules",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def install_modules(venv_path, requirements_file):\n    \"\"\"Installer les modules requis dans l'environnement virtuel\"\"\"\n    pip_path = os.path.join(venv_path, 'Scripts', 'pip') if sys.platform == 'win32' else os.path.join(venv_path, 'bin', 'pip')\n    subprocess.check_call([pip_path, 'install', '-r', requirements_file])\ndef check_and_install_modules(required):\n    \"\"\"Vérifier si les modules requis sont installés et les installer si nécessaire\"\"\"\n    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}    \n    missing = required - installed\n    if not missing:\n        return",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "check_and_install_modules",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def check_and_install_modules(required):\n    \"\"\"Vérifier si les modules requis sont installés et les installer si nécessaire\"\"\"\n    installed = {pkg.metadata['Name'].lower() for pkg in importlib.metadata.distributions()}    \n    missing = required - installed\n    if not missing:\n        return\n    venv_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'venv')    \n    requirements_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'requirements.txt')\n    install_modules(venv_path, requirements_path)\n    print(\"Modules installés avec succès dans l'environnement virtuel.\")",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "is_valid_youtube_url",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def is_valid_youtube_url(url):\n    youtube_regex = r'(https?://)?(www\\.)?' \\\n                    r'(youtube|youtu|youtube-nocookie)\\.(com|be)/' \\\n                    r'(watch\\?v=|embed/|v/|.+\\?v=)?([^&=%\\?]{11})'\n    return bool(re.match(youtube_regex, url))\ndef is_valid_odysee_url(url):\n    odysee_regex = r'https?://odysee\\.com/([a-zA-Z0-9\\-_@:]+)'\n    return bool(re.match(odysee_regex, url))\ndef get_url_from_clipboard():\n    print(\"\\nRécupération de l'URL depuis le presse-papier...\")",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "is_valid_odysee_url",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def is_valid_odysee_url(url):\n    odysee_regex = r'https?://odysee\\.com/([a-zA-Z0-9\\-_@:]+)'\n    return bool(re.match(odysee_regex, url))\ndef get_url_from_clipboard():\n    print(\"\\nRécupération de l'URL depuis le presse-papier...\")\n    url = pyperclip.paste()\n    if not url:\n        print(\"Le presse-papier est vide.\")\n        return None\n    if is_valid_youtube_url(url) or is_valid_odysee_url(url):",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "get_url_from_clipboard",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def get_url_from_clipboard():\n    print(\"\\nRécupération de l'URL depuis le presse-papier...\")\n    url = pyperclip.paste()\n    if not url:\n        print(\"Le presse-papier est vide.\")\n        return None\n    if is_valid_youtube_url(url) or is_valid_odysee_url(url):\n        print(\"URL valide trouvée.\")\n        return url\n    print(\"L'URL dans le presse-papier n'est pas une URL YouTube ou Odysee valide.\")",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "get_video_id",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def get_video_id(url):\n    \"\"\"Extraire l'ID de la vidéo depuis l'URL\"\"\"\n    print(\"\\nExtraction de l'ID de la vidéo...\")\n    if is_valid_youtube_url(url):\n        video_id = re.search(r'(?:v=|\\/)([0-9A-Za-z_-]{11}).*', url)\n        return video_id.group(1) if video_id else None\n    if is_valid_odysee_url(url):\n        response = requests.get(url)\n        soup = BeautifulSoup(response.content, 'html.parser')\n        return soup.find('title').text",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "download_youtube_audio",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def download_youtube_audio(url):\n    print(\"\\nTéléchargement de l'audio YouTube...\")\n    ydl_opts = {\n        'format': 'bestaudio/best',\n        'postprocessors': [{\n            'key': 'FFmpegExtractAudio',\n            'preferredcodec': 'mp3',\n            'preferredquality': '192',\n        }],\n        'outtmpl': 'temp_audio.%(ext)s',",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "download_odysee_video",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def download_odysee_video(url):\n    print(\"\\nTéléchargement de la vidéo Odysee...\")\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, 'html.parser')\n    script_tag = soup.find('script', type='application/ld+json')\n    json_content = json.loads(script_tag.string)\n    video_url = json_content.get('contentUrl')\n    response = requests.get(video_url, stream=True)\n    video_path = 'temp_video.mp4'\n    with open(video_path, 'wb') as f:",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "convert_video_to_audio",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def convert_video_to_audio(video_path):\n    print(\"\\nConversion de la vidéo en audio...\")\n    audio_path = 'temp_audio.mp3'\n    audio = AudioSegment.from_file(video_path)\n    audio.export(audio_path, format='mp3')\n    print(\"Conversion terminée.\")\n    return audio_path\ndef download_odysee_audio(url):\n    video_path = download_odysee_video(url)\n    response = requests.get(url)",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "download_odysee_audio",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def download_odysee_audio(url):\n    video_path = download_odysee_video(url)\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, 'html.parser')\n    video_title = soup.find('title').text\n    audio_path = convert_video_to_audio(video_path)\n    # os.remove(video_path)\n    return audio_path, video_title\ndef transcribe_audio(audio_path):\n    \"\"\"Transcrire l'audio en texte\"\"\"",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "transcribe_audio",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def transcribe_audio(audio_path):\n    \"\"\"Transcrire l'audio en texte\"\"\"\n    if not audio_path:\n        return None\n    try:\n        print(\"\\nChargement du modèle de transcription...\")\n        model = whisper.load_model(\"small\")\n        # model = whisper.load_model(\"tiny\")\n        print(\"\\nTranscription de l'audio en cours...\")\n        result = model.transcribe(audio_path, task=\"transcribe\")",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "detect_language",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def detect_language(text, verbose=True):\n    if verbose:\n        print(\"\\nDétection de la langue...\")\n    translator = Translator()\n    try:\n        detected = translator.detect(text[:1000])\n        if verbose:\n            print(f\"Langue détectée : {detected.lang}\")\n        return detected.lang\n    except Exception as e:",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def translate_text(text, target_lang=\"fr\"):\n    if not text:\n        return None\n    source_lang = detect_language(text, True)\n    if source_lang == target_lang:\n        print(f\"Le texte est déjà en {target_lang}. Aucune traduction nécessaire.\")\n        return text\n    print(\"\\nTraduction du texte en cours...\")\n    translator = Translator()\n    max_chunk_size = 5000",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "save_transcription",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def save_transcription(text, filename):\n    \"\"\"Sauvegarder la transcription dans un fichier\"\"\"\n    if not text:\n        print(\"Aucun texte à sauvegarder.\")\n        return\n    parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    filename_safe = re.sub(r'[^\\w\\s.-]', '', filename)\n    full_path = os.path.join(parent_dir, filename_safe)\n    with open(full_path, 'w', encoding='utf-8') as f:\n        f.write(text)",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "generate_translated_file",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def generate_translated_file(transcription ,detected_lang, video_id, video_title):\n    \"\"\"Générer le fichier traduit\"\"\"\n    target_lang = {\"fr\": \"en\", \"en\": \"fr\"}\n    translated_text = translate_text(transcription, target_lang[detected_lang])\n    if translated_text:\n        translated_text = re.sub(r'([.!?...])(\\S)', r'\\1 \\2', translated_text)\n        filename_translated = f\"{video_id}_{video_title[:30]}_{target_lang[detected_lang].upper()}.txt\"\n        filename_translated = re.sub(r'[^\\w\\-_\\. ]', '_', filename_translated)\n        print(\"filename_translated\", filename_translated)\n        save_transcription(translated_text, filename_translated)",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "def main():\n    print(\"\\n===== Début du processus =====\\n\")\n    url = get_url_from_clipboard()\n    if not url:\n        return\n    video_id = get_video_id(url)\n    if not video_id:\n        print(\"Impossible d'extraire l'ID de la vidéo.\")\n        return\n    print(f\"\\nTraitement de la vidéo depuis l'URL : {url}\")",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "script_dir",
        "kind": 5,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "script_dir = os.path.dirname(os.path.abspath(__file__))\nrequirements_path = os.path.join(script_dir, 'requirements.txt')\nrequired_modules = read_requirements(requirements_path)\ntry:\n    check_and_install_modules(required_modules)\nexcept Exception as e:\n    print(f\"Erreur lors de l'installation des modules : {e}\")\n    sys.exit(1)\n# Importer les modules nécessaires\ntry:",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "requirements_path",
        "kind": 5,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "requirements_path = os.path.join(script_dir, 'requirements.txt')\nrequired_modules = read_requirements(requirements_path)\ntry:\n    check_and_install_modules(required_modules)\nexcept Exception as e:\n    print(f\"Erreur lors de l'installation des modules : {e}\")\n    sys.exit(1)\n# Importer les modules nécessaires\ntry:\n    import pyperclip",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "required_modules",
        "kind": 5,
        "importPath": "Transcription_python.transcritption_files.transcription_script",
        "description": "Transcription_python.transcritption_files.transcription_script",
        "peekOfCode": "required_modules = read_requirements(requirements_path)\ntry:\n    check_and_install_modules(required_modules)\nexcept Exception as e:\n    print(f\"Erreur lors de l'installation des modules : {e}\")\n    sys.exit(1)\n# Importer les modules nécessaires\ntry:\n    import pyperclip\n    import json",
        "detail": "Transcription_python.transcritption_files.transcription_script",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "description": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "TestBasicConnections",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:\n            warnings.warn(\"Skipping test_remote_connection\")",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestThreadedConnection",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestThreadedConnection(unittest.TestCase):\n    def test_initialised_thread(self):\n        \"\"\"A WMI connection in a thread which has been initialised for COM\n        should succeed.\n        \"\"\"\n        def f(q):\n            pythoncom.CoInitialize()\n            try:\n                try:\n                    wmi.WMI()",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMoniker",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestMoniker(unittest.TestCase):\n    def test_moniker(self):\n        \"\"\"Look at all possible options for moniker construction and pass\n        them through to a WMI connector\n        \"\"\"\n        for computer in COMPUTERS:\n            if computer in (None, \".\"):\n                local_authorities = [None]\n            else:\n                local_authorities = AUTHORITIES",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestFunctions",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestFunctions(unittest.TestCase):\n    times = [\n       ((2000, 1, 1), \"20000101******.******+***\"),\n       ((2000, 1, 1, 10, 0, 0), \"20000101100000.******+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100), \"20000101100000.000100+***\"),\n       ((2000, 1, 1, 10, 0, 0, 100, \"GMT\"), \"20000101100000.000100+GMT\")\n    ]\n    def test_signed_to_unsigned(self):\n        tests = [\n           (0, 0),",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWMI",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestWMI(unittest.TestCase):\n    def setUp(self):\n        self.connection = wmi.WMI(namespace=\"root/cimv2\", find_classes=False)\n        self.logical_disks = set(self.connection.Win32_LogicalDisk())\nclass TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestNamespace",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestNamespace(TestWMI):\n    def test_subclasses_of_simple(self):\n        self.assert_(\"Win32_ComputerSystem\" in self.connection.subclasses_of())\n    def test_subclasses_of_subtree(self):\n        self.assert_(\"Win32_Desktop\" in self.connection.subclasses_of(\"CIM_Setting\"))\n    def test_subclasses_of_pattern(self):\n        self.assert_(set([\"Win32_LogicalDisk\", \"Win32_MappedLogicalDisk\"]) <= set(self.connection.subclasses_of(\"CIM_LogicalDevice\", \"Win32_.*Disk\")))\n    def test_instances(self):\n        self.assertEquals(self.logical_disks, set(self.connection.instances(\"Win32_LogicalDisk\")))\n    def test_new(self):",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestClass",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestClass(TestWMI):\n    def test_class_from_namespace(self):\n        self.assert_(self.connection.Win32_ComputerSystem._namespace is self.connection)\n    def test_class_without_namespace(self):\n        wmi_class = wmi.GetObject(\"winmgmts:Win32_ComputerSystem\")\n        self.assert_(wmi._wmi_class(None, wmi_class)._namespace)\n    def test_query(self):\n        self.assertEquals(\n            set(self.connection.Win32_ComputerSystem.query()),\n            set(self.connection.query(\"SELECT * FROM Win32_ComputerSystem\"))",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWatcher",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestWatcher(TestWMI):\n    def new_letter(self):\n        return \\\n            set(\"%s:\" % chr(i) for i in range(ord('A'), 1 + ord('Z'))).\\\n            difference(d.DeviceID for d in self.connection.Win32_LogicalDisk()).\\\n            pop()\n    @staticmethod\n    def create(new_letter):\n        #~ print(\"about to create drive with letter\", new_letter)\n        here = os.path.dirname(os.path.abspath(__file__))",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMethods",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestMethods(TestWMI):\n    def test_exists(self):\n        \"Check that a well-known method is available by attribute\"\n        self.assert_(self.connection.Win32_Process.Create)\n    def test_params(self):\n        \"Check that the names and arrayness of params are picked up when not arrays\"\n        self.assertEquals(\n            [(n, False) for n in [\"CommandLine\", \"CurrentDirectory\", \"ProcessStartupInformation\"]],\n            self.connection.Win32_Process.Create.in_parameter_names\n        )",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestProperties",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestProperties(TestWMI):\n    def test_access(self):\n        \"Check that all properties are available as attributes\"\n        for d in self.logical_disks:\n            break\n        for p in d.ole_object.Properties_:\n            self.assertEqual(p.Value, getattr(d, p.Name))\n    def test_attribute_passthrough(self):\n        \"Check that unknown attributes are passed through to the underlying object\"\n        for d in self.logical_disks:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstances",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestInstances(TestWMI):\n    def test_hashable(self):\n        \"Ensure instances are hashable so can be used in a set/dict\"\n        self.assert_(dict.fromkeys(self.logical_disks))\n    def test_equalable(self):\n        \"Ensure instances compare equal\"\n        self.assertEqual(self.logical_disks, self.logical_disks)\n    def test_not_equal_to_anything_else(self):\n        \"Ensure WMI instances are not equal to non-WMI instances\"\n        for d in self.logical_disks:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstanceCreation",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestInstanceCreation(TestWMI):\n    def test_create_instance(self):\n        self.assert_(isinstance(self.connection.Win32_ProcessStartup.new(ShowWindow=2), wmi._wmi_object))\nclass TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "TestAssociations",
        "kind": 6,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "class TestAssociations(TestWMI):\n    def test_all_properties_available(self):\n        #\n        # An association can contain not only the associated\n        # classes but also extra information as well. Ensure\n        # that both types of data are correctly handled.\n        #\n        for q in self.connection.Win32_DiskQuota():\n            for p in q.properties:\n                try:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "ini",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "ini = ConfigParser.SafeConfigParser()\nini.read([\"wmitest.master.ini\", \"wmitest.ini\"])\nsettings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "settings = {}\nif ini.has_section(\"settings\"):\n    settings.update(ini.items(\"settings\"))\nexcludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "excludes",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "excludes = [i.strip() for i in settings.get(\"excludes\", \"\").split(\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "COMPUTERS",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "COMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n    COMPUTERS.append(settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "IMPERSONATION_LEVELS",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "IMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHENTICATION_LEVELS",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "AUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHORITIES",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "AUTHORITIES = [None]\nif set([\"domain\", \"machine\"]) <= set(settings):\n    #~ AUTHORITIES.append(\"kerberos:%s\" % settings['domain'])\n    AUTHORITIES.append(\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "PRIVILEGES",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "PRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "peekOfCode": "NAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections(unittest.TestCase):\n    def test_basic_connection(self):\n        \"Check that a standard connection works\"\n        self.assert_(wmi.WMI())\n    def test_remote_connection(self):\n        \"Check that a remote connection works, if specified\"\n        if \"machine\" in settings:\n            self.assert_(wmi.WMI(settings['machine']))\n        else:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmitest",
        "documentation": {}
    },
    {
        "label": "link",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "start_doc",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def start_doc(title):\n    doc[:] = []\n    doc.append(\"\"\"\n    <html>\n    <head>\n    <title>%(title)s</title>\n    <style>\n    body {font-family : Verdana, sans-serif; font-size : 84%%; margin : 3em;}\n    table.items {padding-left : 30px;}\n    li, td {font-family : \"Courier New\", monospace;}",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "finish_doc",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def finish_doc():\n    doc.append(\"\"\"\n    </body>\n    </html>\n    \"\"\" % locals())\ndef doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_table",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def doc_table(items, n_cols=3, callback=None):\n    n_rows, n_spare_cols = divmod(len(items), n_cols)\n    doc.append('<table cellspacing=0 class=\"items\">')\n    for n_row in range(n_rows):\n        doc.append(\"<tr>\")\n        for n_col in range(n_cols):\n            item = items[n_cols * n_col + n_row]\n            if callback:\n                item = callback(item)\n            doc.append(\"<td><li>%s</li></td>\" % item)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_breadcrumbs",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def doc_breadcrumbs(computer, namespace, wmi_class=None):\n    doc.append('<p class=\"breadcrumbs\">')\n    doc.append('%s &rarr; %s' % (link(computer, computer), link(namespace, computer, namespace)))\n    if wmi_class:\n        doc.append(' &rarr; %s' % (link(wmi_class, computer, namespace, wmi_class)))\n    doc.append('</p>')\ndef doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_wmi_class",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def doc_wmi_class(computer, namespace, wmi_class, wmi_connection):\n    start_doc(\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace, wmi_class)\n    doc.append(\"<h2>%(wmi_class)s</h2>\" % locals())\n    klass = getattr(wmi_connection, wmi_class)\n    def property_callback(property_name):\n        property = klass.wmi_property(property_name)\n        mapping = property.qualifiers.get(\"MappingStrings\")\n        if mapping is None:\n            return property_name",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_namespace",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def doc_namespace(computer, namespace, wmi_connection):\n    start_doc(\"WMI: Namespace %(namespace)s on %(computer)s\" % locals())\n    doc_breadcrumbs(computer, namespace)\n    namespaces = namespace.split(\"\\\\\")\n    namespace_links = []\n    for i, n in enumerate(namespaces):\n        namespace_links.append(link(n, computer, \"\\\\\".join(namespaces[:i+1])))\n    doc.append(\"<h2>%s</h2>\" % \"\\\\\".join(namespace_links))\n    doc.append(\"<hr>\")\n    subnamespaces = sorted(wmi_connection.__NAMESPACE())",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_namespace",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def handle_namespace(environ, computer, namespace):\n    if not namespace:\n        wmi_connection = wmi.WMI(computer, namespace=\"root/cimv2\")\n        for setting in wmi_connection.Win32_WMISetting():\n            namespace=setting.ASPScriptDefaultNamespace\n            break\n    wmi_connection = wmi.WMI(computer, namespace=namespace, find_classes=True)\n    wmi_class = shift_path_info(environ)\n    if wmi_class:\n        doc_wmi_class(computer, namespace, wmi_class, wmi_connection)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_computer",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def handle_computer(environ, computer):\n    handle_namespace(environ, computer, shift_path_info(environ))\ndef app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def app(environ, start_response):\n    computer = shift_path_info(environ)\n    if computer == \"favicon.ico\":\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        return []\n    elif computer:\n        start_response(\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n        handle_computer(environ, computer)\n        return(unicode(d).encode(\"utf8\") + unicode(\"\\n\").encode(\"utf8\") for d in doc)\n    else:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_browser",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "def run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print(\"Shutting down gracefully...\")",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "doc = []\ndef link(text, computer, namespace=None, wmi_class=None):\n    link = '<a href=\"/' + quote(computer)\n    if namespace:\n        link += \"/\" + quote(namespace)\n    if wmi_class:\n        link += \"/\" + quote(wmi_class)\n    return link + '\">' + escape(text) + '</a>'\ndef start_doc(title):\n    doc[:] = []",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "description": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "peekOfCode": "PORT = 8010\ndef run_browser():\n    import os\n    os.startfile(\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n    threading.Timer(3.0, run_browser).start()\n    httpd = make_server('', PORT, app)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:",
        "detail": "Transcription_python.video_audio_download.venv.Scripts.wmiweb",
        "documentation": {}
    },
    {
        "label": "read_requirements",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def read_requirements():\n    \"\"\"Lire les packages requis dans le fichier de requirements\"\"\"\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    requirements_path = os.path.join(script_dir, \"requirements.txt\")\n    required_packages = set()\n    with open(requirements_path, \"r\") as file:\n        for line in file:\n            line = line.strip()\n            if line and not line.startswith(\"#\"):\n                package_name = line.split(\"==\")[0].split(\"<\")[0].split(\">\")[0].strip()",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "install_modules",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def install_modules(missing_modules):\n    \"\"\"Installer les modules requis dans l'environnement virtuel\"\"\"\n    if missing_modules:\n        print(f\"\\nInstallation des modules manquants: {', '.join(missing_modules)}\")\n        print(\"Cette opération peut prendre de 1 à 2 minutes, veuillez patienter...\")\n    else:\n        print(\"\\nMise à jour des modules...\")\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    venv_path = os.path.join(script_dir, \"venv\")\n    requirements_path = os.path.join(script_dir, \"requirements.txt\")",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "open_file_explorer",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def open_file_explorer(path):\n    \"\"\"\n    Ouvre l'explorateur de fichiers Windows à l'emplacement spécifié.\n    Args:\n        path (str): Chemin du fichier ou du dossier à ouvrir\n    \"\"\"\n    # Normaliser le chemin pour éviter les problèmes avec les barres obliques\n    normalized_path = os.path.normpath(path)\n    # Essayer d'ouvrir l'explorateur de fichiers directement\n    try:",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "get_windows_downloads_folder",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def get_windows_downloads_folder():\n    \"\"\"\n    Obtient le chemin exact du dossier Téléchargements sur Windows en utilisant le registre.\n    Cette méthode fonctionne quelle que soit la langue du système.\n    Returns:\n        str: Chemin du dossier Téléchargements\n    \"\"\"\n    try:\n        # GUID du dossier Téléchargements dans Windows\n        downloads_guid = \"{374DE290-123F-4565-9164-39C4925E467B}\"",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "get_download_path",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def get_download_path(source_type):\n    \"\"\"\n    Obtient le chemin de téléchargement pour un type de source donné.\n    Crée les dossiers nécessaires s'ils n'existent pas.\n    Args:\n        source_type (str): Type de source ('youtube', 'youtube_audio', 'odysee', 'odysee_audio', 'generic', 'generic_audio')\n    Returns:\n        str: Chemin complet vers le dossier de téléchargement\n    \"\"\"\n    # Obtenir le dossier Téléchargements/Downloads de l'utilisateur",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "update_yt_dlp",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def update_yt_dlp():\n    \"\"\"Mettre à jour yt-dlp vers la version stable\"\"\"\n    try:\n        print(\"\\nVérification des mises à jour pour yt-dlp...\")\n        print(\n            \"Les mises à jour régulières sont nécessaires pour contourner les changements d'API de YouTube.\"\n        )\n        result = subprocess.run(\n            [sys.executable, \"-m\", \"yt_dlp\", \"--update-to\", \"stable\"],\n            capture_output=True,",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "check_and_export_cookies",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def check_and_export_cookies():\n    \"\"\"Vérifier si le fichier cookies.txt existe, sinon l'exporter depuis Chrome\"\"\"\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    cookies_file = os.path.join(script_dir, \"cookies.txt\")\n    if os.path.exists(cookies_file):\n        # Le fichier de cookies existe déjà, vérifier s'il est valide\n        try:\n            import http.cookiejar\n            cookie_jar = http.cookiejar.MozillaCookieJar(cookies_file)\n            cookie_jar.load()",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "check_and_install_modules",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def check_and_install_modules():\n    \"\"\"Vérifier si les modules requis sont installés et les installer si nécessaire\"\"\"\n    required = read_requirements()\n    # Supprimer importlib-metadata de la liste des modules requis car il est intégré à Python 3.8+\n    if \"importlib-metadata\" in required:\n        required.remove(\"importlib-metadata\")\n    # Obtenir la liste des packages installés\n    installed = {\n        pkg.metadata[\"Name\"].lower() for pkg in importlib.metadata.distributions()\n    }",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "get_available_video_qualities",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def get_available_video_qualities(available_formats):\n    \"\"\"\n    Récupère les formats vidéo disponibles, limités à 1080p maximum.\n    Retourne une liste de formats triés par qualité.\n    \"\"\"\n    # Définir les résolutions standard à proposer\n    standard_resolutions = [1080, 720, 480]\n    # Préparer les options de qualité à présenter à l'utilisateur\n    quality_options = []\n    # Filtrer les formats qui contiennent de la vidéo (pas seulement audio)",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "is_valid_youtube_url",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def is_valid_youtube_url(url):\n    youtube_regex = (\n        r\"(https?://)?(www\\.)?\"\n        r\"(youtube|youtu|youtube-nocookie)\\.(com|be)/\"\n        r\"(watch\\?v=|embed/|v/|.+\\?v=)?([^&=%\\?]{11})\"\n    )\n    return bool(re.match(youtube_regex, url))\ndef is_valid_odysee_url(url):\n    odysee_regex = r\"https?://odysee\\.com/([a-zA-Z0-9\\-_@:]+)\"\n    return bool(re.match(odysee_regex, url))",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "is_valid_odysee_url",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def is_valid_odysee_url(url):\n    odysee_regex = r\"https?://odysee\\.com/([a-zA-Z0-9\\-_@:]+)\"\n    return bool(re.match(odysee_regex, url))\ndef is_valid_url(url):\n    \"\"\"Vérifie si la chaîne est une URL valide\"\"\"\n    url_regex = r\"^https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)$\"\n    return bool(re.match(url_regex, url))\ndef get_url_from_clipboard():\n    \"\"\"Récupère et valide l'URL depuis le presse-papier\"\"\"\n    print(\"\\nRécupération de l'URL depuis le presse-papier...\")",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "is_valid_url",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def is_valid_url(url):\n    \"\"\"Vérifie si la chaîne est une URL valide\"\"\"\n    url_regex = r\"^https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)$\"\n    return bool(re.match(url_regex, url))\ndef get_url_from_clipboard():\n    \"\"\"Récupère et valide l'URL depuis le presse-papier\"\"\"\n    print(\"\\nRécupération de l'URL depuis le presse-papier...\")\n    url = pyperclip.paste()\n    if not url:\n        print(\"Le presse-papier est vide.\")",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "get_url_from_clipboard",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def get_url_from_clipboard():\n    \"\"\"Récupère et valide l'URL depuis le presse-papier\"\"\"\n    print(\"\\nRécupération de l'URL depuis le presse-papier...\")\n    url = pyperclip.paste()\n    if not url:\n        print(\"Le presse-papier est vide.\")\n        return None\n    if not is_valid_url(url):\n        print(\"Le contenu du presse-papier n'est pas une URL valide.\")\n        return None",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "download_youtube_video",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def download_youtube_video(url):\n    print(\"\\nAnalyse de la vidéo YouTube...\")\n    # Demander à l'utilisateur s'il souhaite télécharger la vidéo ou seulement l'audio\n    print(\"\\nQue souhaitez-vous télécharger ?\")\n    print(\"1. Vidéo (avec audio)\")\n    print(\"2. Audio uniquement (MP3)\")\n    download_type = None\n    while download_type is None:\n        try:\n            choice = input(",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "download_odysee_video",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def download_odysee_video(url):\n    print(\"\\nTéléchargement de la vidéo Odysee...\")\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    local_path = get_download_path(\"odysee\")\n    video_name = soup.find(\"title\").text + \".mp4\"\n    video_path = os.path.join(local_path, video_name)\n    # Étape 1 : Vérifier si le fichier existe déjà\n    if os.path.exists(video_path):\n        print(",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "download_generic_video",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def download_generic_video(url):\n    \"\"\"Télécharge une vidéo depuis une URL générique\"\"\"\n    print(\"\\nTéléchargement de la vidéo depuis une URL générique...\")\n    local_path = get_download_path(\"generic\")\n    # Note: get_download_path crée déjà le dossier s'il n'existe pas\n    try:\n        headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36\"\n        }\n        response = requests.get(url, headers=headers)",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Transcription_python.video_audio_download.download_video_audio",
        "description": "Transcription_python.video_audio_download.download_video_audio",
        "peekOfCode": "def main():\n    print(\"\\n===== Début du processus =====\\n\")\n    result = get_url_from_clipboard()\n    if not result:\n        return\n    type_url, url = result\n    print(f\"\\nTraitement de la vidéo depuis l'URL : {url}\")\n    try:\n        if type_url == \"youtube\":\n            download_youtube_video(url)",
        "detail": "Transcription_python.video_audio_download.download_video_audio",
        "documentation": {}
    },
    {
        "label": "cookies",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.export_cookies",
        "description": "Transcription_python.video_audio_download.export_cookies",
        "peekOfCode": "cookies = browser_cookie3.chrome(domain_name='.youtube.com')\ncookie_jar = http.cookiejar.MozillaCookieJar('cookies.txt')\nfor cookie in cookies:\n    cookie_jar.set_cookie(cookie)\ncookie_jar.save()",
        "detail": "Transcription_python.video_audio_download.export_cookies",
        "documentation": {}
    },
    {
        "label": "cookie_jar",
        "kind": 5,
        "importPath": "Transcription_python.video_audio_download.export_cookies",
        "description": "Transcription_python.video_audio_download.export_cookies",
        "peekOfCode": "cookie_jar = http.cookiejar.MozillaCookieJar('cookies.txt')\nfor cookie in cookies:\n    cookie_jar.set_cookie(cookie)\ncookie_jar.save()",
        "detail": "Transcription_python.video_audio_download.export_cookies",
        "documentation": {}
    }
]